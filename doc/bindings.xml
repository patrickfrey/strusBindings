<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<bindings>
<class id="Term">
<description>Single term occurrence in the document</description>

<method id="type" return="string">
<description>Get the type name ot the term</description>
</method>

<method id="value" return="string">
<description>Get the value ot the term</description>
</method>

<method id="position" return="int">
<description>Get the word count position ot the term</description>
</method>

</class>
<description>Meta data table element of a document</description>
<class id="MetaData">

<method id="name" return="string">
<description>Get the name of the document meta data element</description>
</method>

<method id="value" return="variant">
<description>Get the value of the document meta data element</description>
</method>

</class>
<class id="Attribute">
<description>Attribute of a document</description>

<method id="name" return="string">
<description>Get the name of the document attribute</description>
</method>

<method id="value" return="string">
<description>Get the value of the document attribute</description>
</method>

</class>
<class id="Document">
<description>Document definition</description>

<method id="addSearchIndexTerm" return="void">
<param name="type" type="string">
<description>term type name of the search index term</description>
</param>
<param name="value" type="string">
<description>term value name of the search index term</description>
</param>
<param name="position" type="int">
<description>word count position of the search index term</description>
</param>
<description>Add a single term occurrence to the document for retrieval (inverted index)</description>
</method>

<method id="addForwardIndexTerm" return="void">
<param name="type" type="string">
<description>term type name of the forward index term</description>
</param>
<param name="value" type="string">
<description>term value name of the forward index term</description>
</param>
<param name="position" type="int">
<description>word count position of the forward index term</description>
</param>
<description>Add a single term occurrence to the document for summarization (forward index)</description>
</method>

<method id="setMetaData" return="void">
<param name="name" type="string">
<description>name ot the meta data element</description>
</param>
<param name="value" type="string">
<description>value of the meta data element</description>
</param>
<description>Define a meta data table element value of the document for query restrictions and summarization</description>
</method>

<method id="setAttribute" return="void">
<param name="name" type="string">
<description>name of the document attribute</description>
</param>
<param name="value" type="string">
<description>value of the document attribute</description>
</param>
<description>Define an attribute of the document for summarization</description>
</method>

<method id="setUserAccessRight" return="void">
<param name="username" type="string">
<description>name of user that is allowed to access this document</description>
</param>
<description>Allow a user to access the document</description>
<remark>This function is only implemented if ACL is enabled in the storage</remark>
</method>

<method id="setDocid" return="void">
<param name="docid" type="string">
<description>identifier of the document</description>
</param>
<description>Set the document identifier (docid) of the document</description>
</method>

<method id="searchIndexTerms" return="vector<Term>">
<description>Get the list of search terms of this document</description>
</method>

<method id="forwardIndexTerms" return="vector<Term>">
<description>Get the list of forward terms of this document</description>
</method>

<method id="metaData" return="vector<MetaData>">
<description>Get the list of meta data of this document</description>
</method>

<method id="attributes" return="vector<Attribute>">
<description>Get the list of attributes of this document</description>
</method>

<method id="users" return="vector<string>">
<description>Get the list of users that are allowed to access this document</description>
</method>

<method id="docid" return="string">
<description>Get the document identifier (docid) of the document</description>
</method>

</class>
<class id="DocumentAnalyzer">

<description>Analyzer object representing a program for segmenting, tokenizing and normalizing a document into atomic parts, that can be inserted into a storage and be retrieved from there.</description>
<remark>The only way to construct a document analyzer instance is to call StrusContext::createDocumentAnalyzer()</remark>

<method id="addSearchIndexFeature" return="void">
<description>Define how a feature to insert into the inverted index (search index) is selected, tokenized and normalized</description>

<param name="type" type="string">
<description>type type of the features produced</description>
</param>

<param name="selectexpr" type="string">
<description>expression selecting the elements to fetch for producing this feature</description>
</param>

<param name="tokenizer" type="Tokenizer">
<description>tokenizer function description to use for this feature</description>
</param>

<param name="normalizers" type="vector<Normalizer>">
<description>list of normalizer function descriptions to use for this feature in the ascending order of appearance</description>
</param>

<param name="options" type="vector<string>">
<description>list of options as strings, one of {"BindPosPred" => the position is bound to the preceeding feature, "BindPosSucc" => the position is bound to the succeeding feature</description>
</param>
</method>


	/// \brief Define how a feature to insert into the forward index (summarization) is selected, tokenized and normalized
	/// \param[in] type type of the features produced
	/// \param[in] selectexpr expression selecting the elements to fetch for producing this feature
	/// \param[in] tokenizer tokenizer function description to use for this feature
	/// \param[in] normalizers list of normalizer function description to use for this feature in the ascending order of appearance
	/// \param[in] options a list of options as strings, one of {"BindPosPred" => the position is bound to the preceeding feature, "BindPosSucc" => the position is bound to the succeeding feature}
	void addForwardIndexFeature(
		const std::string& type,
		const std::string& selectexpr,
		const Tokenizer& tokenizer,
		const std::vector<Normalizer>& normalizers,
		const std::vector<std::string>& options=std::vector<std::string>());

	/// \brief Define how a feature to insert as meta data (summarization) is selected, tokenized and normalized
	/// \param[in] fieldname name of the addressed meta data field.
	/// \param[in] selectexpr expression selecting the elements to fetch for producing this feature
	/// \param[in] tokenizer tokenizer function description to use for this feature
	/// \param[in] normalizers list of normalizer function description to use for this feature in the ascending order of appearance
	void defineMetaData(
		const std::string& fieldname,
		const std::string& selectexpr,
		const Tokenizer& tokenizer,
		const std::vector<Normalizer>& normalizers);

	/// \brief Define how a feature to insert as document attribute (summarization) is selected, tokenized and normalized
	/// \param[in] attribname name of the addressed attribute.
	/// \param[in] selectexpr expression selecting the elements to fetch for producing this feature
	/// \param[in] tokenizer tokenizer function description to use for this feature
	/// \param[in] normalizers list of normalizer function description to use for this feature in the ascending order of appearance
	void defineAttribute(
		const std::string& attribname,
		const std::string& selectexpr,
		const Tokenizer& tokenizer,
		const std::vector<Normalizer>& normalizers);

	/// \brief Analye the content and return the set of features to insert
	Document analyze( const std::string& content);

private:
	/// \brief Constructor used by StrusContext
	friend class StrusContext;
	DocumentAnalyzer( const Reference& objbuilder, const std::string& segmentername);

	Reference m_objbuilder_impl;
	Reference m_analyzer_impl;
};


/// \class QueryAnalyzer
/// \brief Analyzer object representing a set of function for transforming a phrase,
///	the smallest unit in any query language, to a set of terms that can be used
///	to build a query.
/// \remark The only way to construct a query analyzer instance is to call StrusContext::createQueryAnalyzer()
class QueryAnalyzer
{
public:
	/// \brief Copy constructor
	QueryAnalyzer( const QueryAnalyzer& o);
	/// \brief Destructor
	~QueryAnalyzer(){}

	/// \brief Defines a phrase type by name. Phrases can be passed together with this name
	///		to the query analyzer to get the terms for building query.
	/// \param[in] phraseType name of the phrase type defined
	/// \param[in] featureType feature type name assigned to the features created by this phrase type
	/// \param[in] tokenizer tokenizer function description to use for the features of this phrase type
	/// \param[in] normalizers list of normalizer function description to use for the features of this phrase type in the ascending order of appearance
	void definePhraseType(
			const std::string& phraseType,
			const std::string& featureType,
			const Tokenizer& tokenizer,
			const std::vector<Normalizer>& normalizers);

	/// \brief Tokenizes and normalizes a phrase and creates some typed terms out of it according the definition of the phrase type given.
	/// \param[in] phraseType name of the phrase type to use for analysis
	/// \param[in] phraseContent content string of the query phrase to analyze
	std::vector<Term> analyzePhrase(
			const std::string& phraseType,
			const std::string& phraseContent) const;

private:
	/// \brief Constructor used by StrusContext
	friend class StrusContext;
	explicit QueryAnalyzer( const Reference& objbuilder);

	Reference m_objbuilder_impl;
	Reference m_analyzer_impl;
};


/// \brief Singleton object representing the client to the storage 
///	of the information retrieval engine.
/// \remark The only way to construct a storage client instance is to call StrusContext::createStorageClient(const std::string&)
class StorageClient
{
public:
	/// \brief Copy constructor
	StorageClient( const StorageClient& o);

	/// \brief Destructor
	~StorageClient(){}

	/// \brief Get the number of documents inserted into the storage
	GlobalCounter nofDocumentsInserted() const;

	/// \brief Prepare inserting a document into the storage
	/// \remark The document is physically inserted with the next implicit or explicit call of 'flush()'
	void insertDocument( const std::string& docid, const Document& doc);

	/// \brief Prepare deletion of a document from the storage
	/// \remark The document is physically deleted with the next implicit or explicit call of 'flush()'
	void deleteDocument( const std::string& docid);

	/// \brief Delete all document access rights of a user
	void deleteUserAccessRights( const std::string& username);

	/// \brief Commit all insert or delete or user access right change statements open.
	void flush();

	/// \brief Close of the storage client
	void close();

private:
	friend class StrusContext;
	StorageClient( const Reference& objbuilder, const std::string& config);

	friend class Query;
	friend class QueryEval;
	Reference m_objbuilder_impl;
	Reference m_storage_impl;
	Reference m_transaction_impl;
};


class SummarizerConfig
{
public:
	/// \brief Constructor
	SummarizerConfig(){}
	/// \brief Copy constructor
	SummarizerConfig( const SummarizerConfig& o)
		:m_parameters(o.m_parameters),m_features(o.m_features){}

	/// \brief Define a summarizer feature
	void defineParameter( const std::string& name_, const Variant& value_)
	{
		m_parameters[ name_] = value_;
	}

	/// \brief Define a summarizer feature
	void defineFeature( const std::string& class_, const std::string& set_)
	{
		m_features[ class_] = set_;
	}

private:
	friend class QueryEval;
	std::map<std::string,Variant> m_parameters;
	std::map<std::string,std::string> m_features;
};

class WeightingConfig
{
public:
	WeightingConfig(){}
	WeightingConfig( const WeightingConfig& o)
		:m_parameters(o.m_parameters){}

	void defineParameter( const std::string& name_, const Variant& value_)
	{
		m_parameters[ name_] = value_;
	}

	/// \brief Define a weighting feature
	void defineFeature( const std::string& class_, const std::string& set_)
	{
		m_features[ class_] = set_;
	}

private:
	friend class QueryEval;
	std::map<std::string,Variant> m_parameters;
	std::map<std::string,std::string> m_features;
};

/// \brief Forward declaration
class Query;

/// \brief Query program object representing a retrieval method for documents in a storage.
class QueryEval
{
public:
	/// \brief Copy constructor
	QueryEval( const QueryEval& o);
	/// \brief Destructor
	~QueryEval(){}

	/// \brief Declare a term that is used in the query evaluation as structural element without beeing part of the query (for example punctuation used for match phrases summarization)
	void addTerm(
			const std::string& set_,
			const std::string& type_,
			const std::string& value_);

	/// \brief Declare a feature set to be used as selecting feature
	void addSelectionFeature( const std::string& set_);

	/// \brief Declare a feature set to be used as restriction
	void addRestrictionFeature( const std::string& set_);

	/// \brief Declare a summarizer
	/// \param[in] resultAttribute name of the result attribute this summarization result is assigned to
	/// \param[in] name the name of the summarizer to add
	/// \param[in] config the configuration of the summarizer to add
	void addSummarizer(
			const std::string& resultAttribute,
			const std::string& name,
			const SummarizerConfig& config);

	/// \brief Add a weighting function to use as summand of the document weight
	/// \param[in] weight additive weight of the feature (compared with other weighting functions added)
	/// \param[in] name the name of the weighting function to add
	/// \param[in] config the configuration of the function to add
	void addWeightingFunction(
			float weight,
			const std::string& name,
			const WeightingConfig& config);

	/// \brief Create a query based on this query evaluation scheme
	/// \param[in] storage storage to issue the query on
	Query* createQuery( const StorageClient& storage) const;

private:
	/// \brief Constructor used by strusContext
	friend class StrusContext;
	explicit QueryEval( const Reference& objbuilder);

	friend class Query;
	Reference m_objbuilder_impl;
	Reference m_queryeval_impl;
};


/// \brief Attribute of a query evaluation result element
class RankAttribute
{
public:
	/// \brief Constructor
	RankAttribute(){}
	/// \brief Constructor
	RankAttribute( const std::string& name_, const std::string& value_)
		:m_name(name_),m_value(value_){}
	/// \brief Copy connstructor
	RankAttribute( const RankAttribute& o)
		:m_name(o.m_name),m_value(o.m_value){}

	/// \brief Get the name of this attribute
	const std::string& name() const		{return m_name;}
	/// \brief Get the value of this attribute
	const std::string& value() const	{return m_value;}

private:
	friend class Query;
	std::string m_name;
	std::string m_value;
};

/// \brief Weighted document reference with attributes (result of a query evaluation)
class Rank
{
public:
	/// \brief Constructor
	Rank()
		:m_docno(0),m_weight(0.0){}
	/// \brief Constructor
	Rank( Index docno_, float weight_, const std::vector<RankAttribute>& attributes_)
		:m_docno(docno_),m_weight(weight_),m_attributes(attributes_){}
	/// \brief Copy constructor
	Rank( const Rank& o)
		:m_docno(o.m_docno),m_weight(o.m_weight),m_attributes(o.m_attributes){}

	/// \brief Get the internal document nuber used
	Index docno() const					{return m_docno;}
	/// \brief Get the weight of the rank
	float weight() const					{return m_weight;}
	/// \brief Get the attributes
	const std::vector<RankAttribute>& attributes() const	{return m_attributes;}

private:
	friend class Query;
	Index m_docno;
	float m_weight;
	std::vector<RankAttribute> m_attributes;
};

/// \brief Query program object representing a retrieval method for documents in a storage.
class Query
{
public:
	/// \brief Copy constructor
	Query( const Query& o);
	/// \brief Destructor
	~Query(){}

	/// \brief Push a single term feature on the stack
	void pushTerm( const std::string& type_, const std::string& value_);

	/// \brief Create an expression from the topmost 'argc' elements of the stack, pop them from the stack and push the expression as single unit on the stack
	void pushExpression( const std::string& opname_, unsigned int argc, int range_);

	/// \brief Push a duplicate of the topmost element of the query stack
	/// \note This function makes it possible to reference terms or expressions more than once as features or as subexpressions.
	void pushDuplicate();

	/// \brief Attaches a variable to the top expression or term on the query stack.
	/// \note The positions of the query matches of the referenced term or expression can be accessed through this variable in summarization.
	/// \param[in] name_ name of the variable attached
	/// \remark The stack is not changed
	void attachVariable( const std::string& name_);

	/// \brief Create a feature from the top element on the stack (and pop the element from the stack)
	void defineFeature( const std::string& set_, float weight_=1.0);

	/// \brief Define a meta data restrictions
	/// \param[in] compareOp compare operator, one of "=","!=",">=","<=","<",">"
	/// \param[in] name of the meta data field (left side of comparison operator)
	/// \param[in] operand numeric value to compare with the meta data field (right side of comparison operator)
	/// \param[in] newGroup true, if the restriction is not an alternative condition to the previous one defined (alternative conditions are evaluated as logical OR)
	void defineMetaDataRestriction(
			const char* compareOp, const std::string& name,
			const Variant& operand, bool newGroup=true);

	/// \brief Set maximum number of ranks to evaluate (not the maximum size of the result rank list. This is maxNofRanks - minRank)
	void setMaxNofRanks( unsigned int maxNofRanks_);

	/// \brief Set the index of the first rank to be returned
	void setMinRank( unsigned int minRank_);

	/// \brief Set the user of the query (overwrites the current user set silently)
	void setUserName( const std::string& username_);

	/// \brief Evaluate the query
	/// \return the result
	std::vector<Rank> evaluate() const;

private:
	friend class QueryEval;
	Query( const Reference& objbuilder_impl_, const Reference& storage_impl_, const Reference& queryeval_impl_, const Reference& query_impl_)
		:m_objbuilder_impl(objbuilder_impl_),m_storage_impl(storage_impl_),m_queryeval_impl(queryeval_impl_),m_query_impl(query_impl_){}

	Reference m_objbuilder_impl;
	Reference m_storage_impl;
	Reference m_queryeval_impl;
	Reference m_query_impl;
};


/// \brief Object holding the global context of the strus IR engine
class StrusContext
{
public:
	/// \brief Constructor for local mode with own module loader
	StrusContext();
	/// \brief Constructor for remote mode (objects of the context are living on a server connected via RPC)
	/// \warning The RPC mode is only desinged for trusted clients. It is highly insecure if not strictly used in a private network only.
	StrusContext( const char* connectionstring);
	/// \brief Copy constructor
	StrusContext( const StrusContext& o);
	/// \brief Destructor
	~StrusContext(){}

	/// \brief Load a module
	/// \remark Only implemented in local mode with own module loader (see constructors)
	void loadModule( const std::string& name_);

	/// \brief Define where to load modules from
	/// \param[in] paths semicolon separated list of module search paths
	/// \remark Only implemented in local mode with own module loader (see constructors)
	void addModulePath( const std::string& paths_);

	/// \brief Define where to load analyzer resource files from
	/// \param[in] paths semicolon separated list of module search paths
	/// \remark Only implemented in local mode with own module loader (see constructors)
	void addResourcePath( const std::string& paths_);

	/// \brief Create a storage client instance
	StorageClient createStorageClient( const std::string& config_);

	/// \brief Create a new storage (physically) described by config
	/// \remark Fails if the storage already exists
	void createStorage( const std::string& config_);

	/// \brief Delete the storage (physically) described by config
	/// \note Handle this function carefully
	void destroyStorage( const std::string& config_);

	/// \brief Create a document analyzer instance
	/// \param[in] segmentername_ name of the segmenter to use (if empty then the default segmenter is used)
	DocumentAnalyzer createDocumentAnalyzer( const std::string& segmentername_="");

	/// \brief Create a query analyzer instance
	QueryAnalyzer createQueryAnalyzer();

	/// \brief Create a query evaluation instance
	QueryEval createQueryEval();

private:
	void initStorageObjBuilder();
	void initAnalyzerObjBuilder();

private:
	Reference m_moduleloader_impl;
	Reference m_rpc_impl;
	Reference m_storage_objbuilder_impl;
	Reference m_analyzer_objbuilder_impl;
};

#endif



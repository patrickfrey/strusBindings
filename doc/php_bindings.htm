<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><link rel="icon" type="image/ico" href="images/strus.ico"/><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="description" content="Language bindings PHP for strus, a collection of C++ libraries for building a full-text search engine."/><meta name="keywords" content="fulltext search engine C++"/><meta name="author" content="Patrick Frey &lt;patrickpfrey (a) yahoo (dt) com&gt;"/><link rel="stylesheet" type="text/css" href="text-profile.css" title="Text Profile" media="all"/><title>PHP bindings for strus</title></head><body><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63809026-11', 'auto');
  ga('send', 'pageview');
</script><div id="wrap"><div id="content"><h1>PHP language bindings</h1><h2>Introduction</h2><p class="description">This chapter describes the language bindings of strus for PHP
		with examples of how to create and use them.<br/>
		The language bindings have been built using <a href="http://www.swig.org">SWIG</a>
		based on a wrapper C++ interface. This wrapper interface serves as common base
		for all language bindings as a sort of super interface (strus/bindingObjects.hpp).
		If you write a language binding you should have a look at this wrapper interface.
		It is not part of this documentation, because showing it could be misleading.
		</p><h2>Overview</h2><p class="description">
		The root object you construct first in PHP is <a href="#StrusContext">the
		strus context</a>. From this context you can construct the main instances
		of the objects doing the job you want to do. Depending on how you create
		the strus context, the objects you create beginning with the root object
		are accessed directly or they are residing on a server and the language 
		objects serve as proxy for the server objects.
		</p><h2>Examples</h2><p class="description">
		PHP is a value typed language with no explicit typing.<br/>
		In the following examples we refer to the type of an object that 
		exists only as a single instance in the context by using the name of 
		the object type starting with a lower case letter as name of the variable.
		The snippet
		</p><pre><a href="#Query">$query</a> = <a href="#QueryEval">$queryEval</a>-&gt;createQuery( <a href="#Storage">$storage</a>);
		</pre><p class="description">
		describes therefore the construction of an object of type <a href="#Query">Query</a> with the name <i>query</i>
		by an object of type <a href="#QueryEval">QueryEval</a> with name <i>queryEval</i> with the parameter
		of type <a href="#Storage">Storage</a> named <i>storage</i>.
		</p><h3>Create a strus RPC context for a session residing on a server</h3><p class="description">
		You create a remote strus context by calling its constructor with the RPC server address
		as argument.
		</p><pre><a href="#StrusContext">$context</a> = new StrusContext( "localhost:7181" );
		</pre><h3>Create a query evaluation scheme</h3><p class="description">
		A query evaluation scheme is created by calling the context method to create
		a query evaluation instance. The scheme is built by calling the methods for
		building the scheme on this instance. The weighting function configuration is
		defined as associative array. The keys starting with dot '.' reference query
		feature sets used by the scheme.
		</p><pre><a href="#QueryEval">$queryEval</a> = <a href="#StrusContext">$context</a>-&gt;createQueryEval();
# Add weighting of the features of the feature set "<i>docfeat</i>":
<a href="#QueryEval">$queryEval</a>-&gt;addWeightingFunction( 1.0, "BM25", [
                "k1" =&gt; 0.75, "b" =&gt; 2.1,
                "avgdoclen" =&gt; 500,
                ".match" =&gt; "docfeat" ]);

# Define what data is shown to present a result of the query:
<a href="#QueryEval">$queryEval</a>-&gt;addSummarizer(
                "TITLE", "attribute", [ "name" =&gt; "title" ] );
<a href="#QueryEval">$queryEval</a>-&gt;addSummarizer( "CONTENT", "matchphrase", [
                "type" =&gt; "orig", "len" =&gt; 40, "nof" =&gt; 3, "structseek" =&gt; 30,
                "mark" =&gt; '<b>$</b>',
                ".struct" =&gt; "sentence", ".match" =&gt; "docfeat" ] );

# Define the set of features used to select the document that should be weighted as "<i>selfeat</i>":
<a href="#QueryEval">$queryEval</a>-&gt;addSelectionFeature( "selfeat");

		</pre><h3>Analyze a query phrase</h3><p class="description">
		A query in strus is modeled as a set of query phrases combined by some proprietary
		operators of a query language. Strus does not impose any defined query language.
		Maybe there is none. There is a proposition for a query language implemented in
		the utilities program loader library, but it is not mandatory to use it.<br/>
		The query analyzer allows you to define methods of analyzing the basic parts
		called phrases of your query language. The following example shows the definition
		of a phrase type and the analysis ot the phrase "hello world":
		</p><pre><a href="#QueryAnalyzer">$queryAnalyzer</a> = <a href="#StrusContext">$context</a>-&gt;createQueryAnalyzer();
<a href="#QueryAnalyzer">$queryAnalyzer</a>-&gt;definePhraseType( "text", "stem", "word", 
                ["lc",
                ["dictmap", "irregular_verbs_en.txt"],
                ["stem", "en"],
                ["convdia", "en"],
                "lc"]);
<a href="#Term">$terms</a> = <a href="#QueryAnalyzer">$queryAnalyzer</a>-&gt;analyzePhrase( "text", "hello world");
		</pre><h3>Create and evaluate a query</h3><p class="description">
		A query is created by calling the constructing method of the query evaluation instance 
		of the query evaluation scheme you want to use. The query is built by calling the
		query instance methods for constructing the queried terms and structures.
		</p><pre><a href="#Storage">$storageClient</a> = $context-&gt;createStorageClient( "" );
<a href="#Storage">$query</a> = <a href="#QueryEval">$queryEval</a>-&gt;createQuery( "" );

if (count( <a href="#Term">$terms</a>) &gt; 0)
{
        foreach (<a href="#Term">$terms</a> as &amp;<a href="#Term">$term</a>)
        {
                <a href="#Query">$query</a>-&gt;pushTerm( "stem", <a href="#Term">$term</a>-&gt;value);
                <a href="#Query">$query</a>-&gt;pushDuplicate( "stem", <a href="#Term">$term</a>-&gt;value);
                <a href="#Query">$query</a>-&gt;defineFeature( "docfeat");
        }
        <a href="#Query">$query</a>-&gt;pushExpression( "within", count($terms), 100000);
        <a href="#Query">$query</a>-&gt;defineFeature( "selfeat");
}
<a href="#Query">$query</a>-&gt;setMaxNofRanks( $maxNofRanks);
<a href="#Query">$query</a>-&gt;setMinRank( $minRank);
$result = return <a href="#Query">$query</a>-&gt;evaluate();
		</pre><h2>Object types</h2><a name="Term"> </a><h3>Term</h3><p class="description">Single term occurrence in a document.  </p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>type</b></td><td valign="top" align="left">string</td><td valign="top" align="left"/><td valign="top" align="left">Get the type name ot the term.  </td></tr><tr><td valign="top" align="left"><b>value</b></td><td valign="top" align="left">string</td><td valign="top" align="left"/><td valign="top" align="left">Get the value ot the term.  </td></tr><tr><td valign="top" align="left"><b>position</b></td><td valign="top" align="left">int</td><td valign="top" align="left"/><td valign="top" align="left">Get the word count position ot the term.  </td></tr></table></div><a name="MetaData"> </a><h3>MetaData</h3><p class="description">Meta data element of a document.  </p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>name</b></td><td valign="top" align="left">string</td><td valign="top" align="left"/><td valign="top" align="left">Get the name of the document meta data element.  </td></tr><tr><td valign="top" align="left"><b>value</b></td><td valign="top" align="left">
					Any numeric type (byte, int, float)
				</td><td valign="top" align="left"/><td valign="top" align="left">Get the value of the document meta data element.  </td></tr></table></div><a name="Attribute"> </a><h3>Attribute</h3><p class="description">Attribute of a document.  </p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>name</b></td><td valign="top" align="left">string</td><td valign="top" align="left"/><td valign="top" align="left">Get the name of the document attribute.  </td></tr><tr><td valign="top" align="left"><b>value</b></td><td valign="top" align="left">string</td><td valign="top" align="left"/><td valign="top" align="left">Get the value of the document attribute.  </td></tr></table></div><a name="Document"> </a><h3>Document</h3><p class="description">Document definition  </p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>addSearchIndexTerm</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>type</b>:  term type name of the search index term<br/><b>value</b>:  term value of the search index term<br/><b>position</b>:  word count position of the search index term<br/></td><td valign="top" align="left">Add a single term occurrence to the document for retrieval (inverted index).  </td></tr><tr><td valign="top" align="left"><b>addForwardIndexTerm</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>type</b>:  term type name of the forward index term<br/><b>value</b>:  term value of the forward index term<br/><b>position</b>:  word count position of the forward index term<br/></td><td valign="top" align="left">Add a single term occurrence to the document for summarization (forward index).  </td></tr><tr><td valign="top" align="left"><b>setMetaData</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>name</b>:  name ot the meta data element<br/><b>value</b>:  value of the meta data element<br/></td><td valign="top" align="left">Define a meta data table element value of the document for query restrictions and summarization.  </td></tr><tr><td valign="top" align="left"><b>setAttribute</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>name</b>:  name of the document attribute<br/><b>value</b>:  value of the document attribute<br/></td><td valign="top" align="left">Define an attribute of the document for summarization.  </td></tr><tr><td valign="top" align="left"><b>setUserAccessRight</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>username</b>:  name of user that is allowed to access this document<br/></td><td valign="top" align="left">Allow a user to access the document. This function is only implemented if ACL is enabled in the storage. </td></tr><tr><td valign="top" align="left"><b>setDocid</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>docid</b>:  identifier of the document<br/></td><td valign="top" align="left">Set the document identifier (docid) of the document.  </td></tr><tr><td valign="top" align="left"><b>searchIndexTerms</b></td><td valign="top" align="left"><a href="#Term">Term[]</a></td><td valign="top" align="left"/><td valign="top" align="left">Get the list of search terms of this document  </td></tr><tr><td valign="top" align="left"><b>forwardIndexTerms</b></td><td valign="top" align="left"><a href="#Term">Term[]</a></td><td valign="top" align="left"/><td valign="top" align="left">Get the list of forward terms of this document  </td></tr><tr><td valign="top" align="left"><b>metaData</b></td><td valign="top" align="left"><a href="#MetaData">MetaData[]</a></td><td valign="top" align="left"/><td valign="top" align="left">Get the list of meta data of this document  </td></tr><tr><td valign="top" align="left"><b>attributes</b></td><td valign="top" align="left"><a href="#Attribute">Attribute[]</a></td><td valign="top" align="left"/><td valign="top" align="left">Get the list of attributes of this document  </td></tr><tr><td valign="top" align="left"><b>users</b></td><td valign="top" align="left">string[]</td><td valign="top" align="left"/><td valign="top" align="left">Get the list of users that are allowed to access this document  </td></tr><tr><td valign="top" align="left"><b>docid</b></td><td valign="top" align="left">string</td><td valign="top" align="left"/><td valign="top" align="left">Get the document identifier (docid) of the document  </td></tr></table></div><a name="DocumentAnalyzer"> </a><h3>DocumentAnalyzer</h3><p class="description">Analyzer object representing a program for segmenting, tokenizing and normalizing a document into its atomic parts, that can be inserted into a storage and be retrieved from there. The only way to construct a document analyzer instance is to call createDocumentAnalyzer of StrusContext. </p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>addSearchIndexFeature</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>type</b>:  type type of the features produced<br/><b>selectexpr</b>:  expression selecting the elements to fetch for producing this feature<br/><b>tokenizer</b>:  tokenizer function description as list of strings (first element is the function name, the following elements are the parameters) to use for this feature<br/><b>normalizers</b>:  list of normalizer function descriptions  as list of strings (first element is the function name, the following elements are the parameters) to use for this feature in the ascending order of appearance<br/><b>options</b>:  list of options as strings, one of {"BindPosPred" =&gt; the position is bound to the preceeding feature, "BindPosSucc" =&gt; the position is bound to the succeeding feature<br/></td><td valign="top" align="left">Define how a feature to insert into the inverted index (search index) is selected, tokenized and normalized.  </td></tr><tr><td valign="top" align="left"><b>addForwardIndexFeature</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>type</b>:  type type of the features produced<br/><b>selectexpr</b>:  expression selecting the elements to fetch for producing this feature<br/><b>tokenizer</b>:  tokenizer function description as list of strings (first element is the function name, the following elements are the parameters) to use for this feature<br/><b>normalizers</b>:  list of normalizer function descriptions as list of strings (first element is the function name, the following elements are the parameters) to use for this feature in the ascending order of appearance<br/><b>options</b>:  list of options as strings, one of {"BindPosPred" =&gt; the position is bound to the preceeding feature, "BindPosSucc" =&gt; the position is bound to the succeeding feature<br/></td><td valign="top" align="left">Define how a feature to insert into the forward index (for summarization) is selected, tokenized and normalized.  </td></tr><tr><td valign="top" align="left"><b>defineMetaData</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>fieldname</b>:  name of the addressed meta data table element<br/><b>selectexpr</b>:  expression selecting the elements to fetch for producing this feature<br/><b>tokenizer</b>:  tokenizer function description as list of strings (first element is the function name, the following elements are the parameters) to use for this feature<br/><b>normalizers</b>:  list of normalizer function descriptions as list of strings (first element is the function name, the following elements are the parameters) to use for this feature in the ascending order of appearance<br/></td><td valign="top" align="left">Define how a feature to insert as meta data is selected, tokenized and normalized.  </td></tr><tr><td valign="top" align="left"><b>defineStatisticsMetaData</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>fieldname</b>:  name of the addressed meta data table element<br/><b>function</b>:  tokenizer function description as list of strings (first element is the function name, the following elements are the parameters) to use for collecting statistics for the specified field<br/></td><td valign="top" align="left">Declare some collected statistics of the document to be put into the meta data table used for restrictions, weighting and summarization.  </td></tr><tr><td valign="top" align="left"><b>defineAttribute</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>attribname</b>:  name of the addressed attribute<br/><b>selectexpr</b>:  expression selecting the elements to fetch for producing this feature<br/><b>tokenizer</b>:  tokenizer function description as list of strings (first element is the function name, the following elements are the parameters) to use for this feature<br/><b>normalizers</b>:  list of normalizer function descriptions as list of strings (first element is the function name, the following elements are the parameters) to use for this feature in the ascending order of appearance<br/></td><td valign="top" align="left">Define how a feature to insert as document attribute (summarization) is selected, tokenized and normalized.  </td></tr><tr><td valign="top" align="left"><b>analyze</b></td><td valign="top" align="left"><a href="#Document">Document</a></td><td valign="top" align="left"><b>content</b>:  content string (NOT a file name !) of the document to analyze<br/></td><td valign="top" align="left">Analye the content and return the document structure.  </td></tr></table></div><a name="QueryAnalyzer"> </a><h3>QueryAnalyzer</h3><p class="description">Analyzer object representing a set of functions for segmenting, tokenizing and normalizing a phrase into its atomic parts, that can be used for document retrieval. The only way to construct a query analyzer instance is to call createQueryAnalyzer of StrusContext. </p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>definePhraseType</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>phraseType</b>:  name of the phrase type defined<br/><b>featureType</b>:  feature type name assigned to the features created by this phrase type<br/><b>tokenizer</b>:  tokenizer function description as list of strings (first element is the function name, the following elements are the parameters) to use for this phrase type<br/><b>normalizers</b>:  list of normalizer function descriptions as list of strings (first element is the function name, the following elements are the parameters) to use for this phrase type in the ascending order of appearance<br/></td><td valign="top" align="left">Defines a phrase type by name. Phrases can be passed together with this name to the query analyzer to get the terms for building query.  </td></tr><tr><td valign="top" align="left"><b>analyzePhrase</b></td><td valign="top" align="left"><a href="#Term">Term[]</a></td><td valign="top" align="left"><b>phraseType</b>:  name of the phrase type to select analysis method<br/><b>phraseContent</b>:  content string of the phrase to analyze<br/></td><td valign="top" align="left">Tokenizes and normalizes a phrase and creates some typed terms out of it according the definition of the phrase type given.  </td></tr></table></div><a name="StorageClient"> </a><h3>StorageClient</h3><p class="description">Object representing a client connection to the storage . The only way to construct a storage client instance is to call the method createStorageClient of StrusContext. </p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>nofDocumentsInserted</b></td><td valign="top" align="left">
					64 bit integer if available for PHP on the platform,
					otherwise 32 bit integer
				</td><td valign="top" align="left"/><td valign="top" align="left">Get the global number of documents inserted into all storage nodes (of all nodes of the search index).  </td></tr><tr><td valign="top" align="left"><b>insertDocument</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>docid</b>:  the identifier of the document to insert<br/><b>doc</b>:  the structure of the document to insert<br/><a href="#Document">(type Document)</a></td><td valign="top" align="left">Prepare the inserting a document into the storage. The document is physically inserted with the next implicit or explicit call of 'flush' </td></tr><tr><td valign="top" align="left"><b>deleteDocument</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>docid</b>:  the identifier of the document to delete<br/></td><td valign="top" align="left">Prepare the deletion of a document from the storage. The document is physically deleted with the next implicit or explicit call of 'flush' </td></tr><tr><td valign="top" align="left"><b>deleteUserAccessRights</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>username</b>:  the name of the user to delete all access rights (in the local collection)<br/></td><td valign="top" align="left">Prepare the deletion of all document access rights of a user. The user access rights are changed accordingly with the next implicit or explicit call of 'flush' </td></tr><tr><td valign="top" align="left"><b>flush</b></td><td valign="top" align="left"/><td valign="top" align="left"/><td valign="top" align="left">Commit all insert or delete or user access right change statements open.  </td></tr><tr><td valign="top" align="left"><b>close</b></td><td valign="top" align="left"/><td valign="top" align="left"/><td valign="top" align="left">Close the storage client.  </td></tr></table></div><a name="QueryEval"> </a><h3>QueryEval</h3><p class="description">Query evaluation program object representing an information retrieval scheme for documents in a storage.  </p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>addTerm</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>set</b>:  identifier of the term set that is used to address the terms<br/><b>type</b>:  feature type of the of the term<br/><b>value</b>:  feature value of the of the term<br/></td><td valign="top" align="left">Declare a term that is used in the query evaluation as structural element without beeing part of the query (for example punctuation used for match phrases summarization).  </td></tr><tr><td valign="top" align="left"><b>addSelectionFeature</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>set</b>:  identifier of the term set addressing the terms to use for selection<br/></td><td valign="top" align="left">Declare a feature set to be used as selecting feature.  </td></tr><tr><td valign="top" align="left"><b>addRestrictionFeature</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>set</b>:  identifier of the term set addressing the terms to use as restriction<br/></td><td valign="top" align="left">Declare a feature set to be used as restriction.  </td></tr><tr><td valign="top" align="left"><b>addExclusionFeature</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>set</b>:  identifier of the term set addressing the terms to use as exclusion<br/></td><td valign="top" align="left">Declare a feature set to be used as exclusion.  </td></tr><tr><td valign="top" align="left"><b>addSummarizer</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>resultAttribute</b>:  name of the result attribute this summarization result is assigned to<br/><b>name</b>:  the name of the summarizer to add<br/><b>config</b>:  a list of named configuration options of the summarizer to add.
	The values of the configuration options can be numeric or of type string. 
	Key identifiers starting with a dot '.' are declaring feature parameters.
	The names of the configuration key identifiers depend on the summarizer implementation.<br/>
					(type associative array)
				</td><td valign="top" align="left">Declare a summarizer.  </td></tr><tr><td valign="top" align="left"><b>addWeightingFunction</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>weight</b>:  additive weight of the document<br/><b>name</b>:  the name of weighting function to add<br/><b>config</b>:  a list of named configuration options of the weighting function to add.
	The values of the configuration options can be numeric or of type string. 
	Key identifiers starting with a dot '.' are declaring feature parameters.
	The names of the configuration key identifiers depend on the weighting function implementation.<br/>
					(type associative array)
				</td><td valign="top" align="left">Add a weighting function to use as summand of the total document weight.  </td></tr><tr><td valign="top" align="left"><b>createQuery</b></td><td valign="top" align="left"><a href="#Query">Query</a></td><td valign="top" align="left"><b>storage</b>:  storage to execute the query on<br/></td><td valign="top" align="left">Create a query builder based on this query evaluation scheme.  </td></tr></table></div><a name="Query"> </a><h3>Query</h3><p class="description">Object representing an instance of a query for documents in a storage. The only way to construct a query instance is to call the method createQuery of QueryEval. The expressions of the query are constructed as tree with a classical stack machine.</p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>pushTerm</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>type</b>:  query term type name<br/><b>value</b>:  query term value<br/></td><td valign="top" align="left">Push a single term on the stack.  </td></tr><tr><td valign="top" align="left"><b>pushExpression</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>opname</b>:  name of the expression operator<br/><b>argc</b>:  number of operands (topmost elements from stack) of the expression<br/><b>range</b>:  span ot the expression in the document<br/></td><td valign="top" align="left">Create an expression from the topmost 'argc' elements of the stack, pop them from the stack and push the expression as single unit on the stack.  </td></tr><tr><td valign="top" align="left"><b>pushDuplicate</b></td><td valign="top" align="left"/><td valign="top" align="left"/><td valign="top" align="left">Push a duplicate of the topmost element of the query stack. This function makes it possible to reference terms or expressions more than once as features or as subexpressions. </td></tr><tr><td valign="top" align="left"><b>attachVariable</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>name</b>:  name of the variable attached<br/></td><td valign="top" align="left">Attaches a variable to the topmost expression or term on the query stack.  The positions of the query matches of the referenced term or expression in a document can be accessed through this variable in summarization.</td></tr><tr><td valign="top" align="left"><b>defineFeature</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>name</b>:  name of the set that is used to address this feature<br/><b>weight</b>:  individual weight of this feature in the query<br/></td><td valign="top" align="left">Create a feature from the top element on the stack (and pop the element from the stack).  </td></tr><tr><td valign="top" align="left"><b>defineMetaDataRestriction</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>compareOp</b>:  compare operator, one of "=","!=","&gt;=","&lt;=","&lt;","&gt;".<br/><b>name</b>:  name of the meta data field (left side of comparison operator)<br/><b>operand</b>:  numeric value to compare with the meta data field (right side of comparison operator)<br/>
					Any numeric type (byte, int, float)
				<b>newGroup</b>:  true, if the restriction is not an alternative condition to the previous one defined (alternative conditions are evaluated as logical OR)<br/></td><td valign="top" align="left">Define a meta data restriction.  </td></tr><tr><td valign="top" align="left"><b>setMaxNofRanks</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>maxNofRanks</b>:  maximum number of results to return by this query<br/></td><td valign="top" align="left">Set maximum number of ranks to return as query result.  </td></tr><tr><td valign="top" align="left"><b>setMinRank</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>minRank</b>:  index of the first rank to be returned by this query<br/></td><td valign="top" align="left">Set the index of the first rank to be returned by this query.  </td></tr><tr><td valign="top" align="left"><b>addUserName</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>username</b>:  an alternative name of a user for the evaluation of this query<br/></td><td valign="top" align="left">Add a user for this query (as alternative role).  The user restriction applies if no user role specified in the query is allowed to see the document</td></tr><tr><td valign="top" align="left"><b>evaluate</b></td><td valign="top" align="left">
				List of associative arrays with strings as keys and string or numeric values
				</td><td valign="top" align="left"/><td valign="top" align="left">Evaluate this query and return the result. The result is a list of 
ranked documents with attributes. Some result elements are hardcoded like "weight" and "docno". Others
are depending on the summarizer configurations.
The rest is defined by the summarizers used.   </td></tr></table></div><a name="StrusContext"> </a><h3>StrusContext</h3><p class="description">Object holding the global context of the strus information retrieval engine.  There a two modes of this context object operating on a different base.
	If you create this object without parameter, then the context is local.
	In a local context you can load modules, define resources, etc. If you create
	this object with a connection string as parameter, then all object created by
	this context reside on the server (strusRpcServer) addressed with the connection string.
	In this case loaded modules and resources are ignored. What modules to use is then
	specified on server startup.</p><h4>Methods</h4><div id="api"><table border="1"><tr><th width="10%" align="left">Name</th><th width="10%" align="left">Result</th><th width="30%" align="left">Arguments</th><th width="30%" align="left">Description</th></tr><tr><td valign="top" align="left"><b>loadModule</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>paths</b>:  semicolon separated list of module search paths<br/></td><td valign="top" align="left">Load a module. Only implemented in local context mode with own module loader. </td></tr><tr><td valign="top" align="left"><b>addModulePath</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>paths</b>:  semicolon separated list of module search paths or single path<br/></td><td valign="top" align="left">Add a path from where to try to load modules from. Only implemented in local context mode with own module loader. </td></tr><tr><td valign="top" align="left"><b>addResourcePath</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>paths</b>:  semicolon separated list of resource search paths or single path<br/></td><td valign="top" align="left">Add a path from where to try to load resources from. Only implemented in local context mode with own module loader </td></tr><tr><td valign="top" align="left"><b>createStorageClient</b></td><td valign="top" align="left"><a href="#StorageClient">StorageClient</a></td><td valign="top" align="left"><b>config</b>:  configuration string of the storage client or empty, if the default remote storage of the RPC server is chosen<br/></td><td valign="top" align="left">Create a storage client instance.  </td></tr><tr><td valign="top" align="left"><b>createStorage</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>config</b>:  configuration string of the new storage<br/></td><td valign="top" align="left">Create a new storage (physically) described by config-  </td></tr><tr><td valign="top" align="left"><b>destroyStorage</b></td><td valign="top" align="left"/><td valign="top" align="left"><b>config</b>:  configuration string identifying the storage to destroy<br/></td><td valign="top" align="left">Destroy a storage (physically) described by config.  Handle this function carefully</td></tr><tr><td valign="top" align="left"><b>createDocumentAnalyzer</b></td><td valign="top" align="left"><a href="#DocumentAnalyzer">DocumentAnalyzer</a></td><td valign="top" align="left"><b>segmentername</b>:  name of the segmenter to use (if empty then the default segmenter is used)<br/></td><td valign="top" align="left">Create a document analyzer instance-  </td></tr><tr><td valign="top" align="left"><b>createQueryAnalyzer</b></td><td valign="top" align="left"><a href="#QueryAnalyzer">QueryAnalyzer</a></td><td valign="top" align="left"/><td valign="top" align="left">Create a query analyzer instance.  </td></tr><tr><td valign="top" align="left"><b>createQueryAnalyzer</b></td><td valign="top" align="left"><a href="#QueryEval">QueryEval</a></td><td valign="top" align="left"/><td valign="top" align="left">Create a query evaluation instance.  </td></tr></table></div></div></div></body></html>

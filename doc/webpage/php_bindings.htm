<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><link rel="icon" type="image/ico" href="images/strus.ico"/><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="description" content="Language bindings PHP for strus, a collection of C++ libraries for building a full-text search engine."/><meta name="keywords" content="fulltext search engine C++"/><meta name="author" content="Patrick Frey &lt;patrickpfrey (a) yahoo (dt) com&gt;"/><link rel="stylesheet" type="text/css" href="text-profile.css" title="Text Profile" media="all"/><title>PHP bindings for strus</title>
</head>
<body>
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63809026-10', 'auto');
  ga('send', 'pageview');

</script>
<div id="wrap"><div id="content"><h1>PHP language bindings</h1><h2>Introduction</h2><p class="description">This chapter describes the language bindings of strus for PHP
		with examples of how to create and use them.<br/>
		The language bindings have been built using <a href="http://www.swig.org">SWIG</a>
		based on a wrapper C++ interface. This wrapper interface serves as common base
		for all language bindings as a sort of super interface (strus/bindingObjects.hpp).
		There exists a <a href="docygen interface documentation of the PHP bindings">http://patrickfrey.github.io/strusBindings/doc/php/doxygen/html/index.html</a>.

		</p><h2>Tutorial</h2><p class="description">
		You'll fine a tutorial based on a docker image <a href="http://www.codeproject.com/Articles/1009582/Building-a-search-engine-with-Strus-tutorial">here</a>.
		</p><h2>Overview</h2><p class="description">
		The root object you construct first in PHP is <a href="#StrusContext">the
		strus context</a>. From this context you can construct the main instances
		of the objects doing the job you want to do. Depending on how you create
		the strus context, the objects you create beginning with the root object
		are accessed directly or they are residing on a server and the language 
		objects serve as proxy for the server objects.
		</p><h2>Examples</h2><p class="description">
		PHP is a value typed language with no explicit typing.<br/>
		In the following examples we refer to the type of an object that 
		exists only as a single instance in the context by using the name of 
		the object type starting with a lower case letter as name of the variable.
		The snippet
		</p><pre><a href="#Query">$query</a> = <a href="#QueryEval">$queryEval</a>-&gt;createQuery( <a href="#Storage">$storage</a>);
		</pre><p class="description">
		describes therefore the construction of an object of type <a href="#Query">Query</a> with the name <i>query</i>
		by an object of type <a href="#QueryEval">QueryEval</a> with name <i>queryEval</i> with the parameter
		of type <a href="#Storage">Storage</a> named <i>storage</i>.
		</p><h3>Create a strus RPC context for a session residing on a server</h3><p class="description">
		You create a remote strus context by calling its constructor with the RPC server address
		as argument. The strus RPC server serving the requests for such a proxy is part of 
		the <a href="http://patrickfrey.github.io/strusRpc/doc/doxygen/html/index.html">strusRpc project</a>.
		</p><pre><a href="#StrusContext">$context</a> = new StrusContext( "localhost:7181" );
		</pre><h3>Create a query evaluation scheme</h3><p class="description">
		A query evaluation scheme is created by calling the context method to create
		a query evaluation instance. The scheme is built by calling the methods for
		building the scheme on this instance. The weighting function configuration is
		defined as associative array. The keys starting with dot '.' reference query
		feature sets used by the scheme.
		</p><pre><a href="#QueryEval">$queryEval</a> = <a href="#StrusContext">$context</a>-&gt;createQueryEval();
# Add weighting of the features of the feature set "<i>docfeat</i>":
<a href="#QueryEval">$queryEval</a>-&gt;addWeightingFunction( 1.0, "BM25", [
                "k1" =&gt; 0.75, "b" =&gt; 2.1,
                "avgdoclen" =&gt; 500,
                ".match" =&gt; "docfeat" ]);

# Define what data is shown to present a result of the query:
<a href="#QueryEval">$queryEval</a>-&gt;addSummarizer(
                "TITLE", "attribute", [ "name" =&gt; "title" ] );
<a href="#QueryEval">$queryEval</a>-&gt;addSummarizer( "CONTENT", "matchphrase", [
                "type" =&gt; "orig", "len" =&gt; 40, "nof" =&gt; 3, "structseek" =&gt; 30,
                "mark" =&gt; '<b>$</b>',
                ".struct" =&gt; "sentence", ".match" =&gt; "docfeat" ] );

# Define the set of features used to select the document that should be weighted as "<i>selfeat</i>":
<a href="#QueryEval">$queryEval</a>-&gt;addSelectionFeature( "selfeat");

		</pre><h3>Analyze a query phrase</h3><p class="description">
		A query in strus is modeled as a set of query phrases combined by some proprietary
		operators of a query language. Strus does not impose any defined query language.
		Maybe there is none. There is a proposition for a query language implemented in
		the utilities program loader library, but it is not mandatory to use it.<br/>
		The query analyzer allows you to define methods of analyzing the basic parts
		called phrases of your query language. The following example shows the definition
		of a phrase type and the analysis ot the phrase "hello world":
		</p><pre><a href="#QueryAnalyzer">$queryAnalyzer</a> = <a href="#StrusContext">$context</a>-&gt;createQueryAnalyzer();
<a href="#QueryAnalyzer">$queryAnalyzer</a>-&gt;definePhraseType( "text", "stem", "word", 
                ["lc",
                ["dictmap", "irregular_verbs_en.txt"],
                ["stem", "en"],
                ["convdia", "en"],
                "lc"]);
<a href="#Term">$terms</a> = <a href="#QueryAnalyzer">$queryAnalyzer</a>-&gt;analyzePhrase( "text", "hello world");
		</pre><h3>Create and evaluate a query</h3><p class="description">
		A query is created by calling the constructing method of the query evaluation instance 
		of the query evaluation scheme you want to use. The query is built by calling the
		query instance methods for constructing the queried terms and structures.
		</p><pre><a href="#Storage">$storageClient</a> = $context-&gt;createStorageClient( "" );
<a href="#Storage">$query</a> = <a href="#QueryEval">$queryEval</a>-&gt;createQuery( "" );

if (count( <a href="#Term">$terms</a>) &gt; 0)
{
        foreach (<a href="#Term">$terms</a> as &amp;<a href="#Term">$term</a>)
        {
                <a href="#Query">$query</a>-&gt;pushTerm( "stem", <a href="#Term">$term</a>-&gt;value);
                <a href="#Query">$query</a>-&gt;pushDuplicate( "stem", <a href="#Term">$term</a>-&gt;value);
                <a href="#Query">$query</a>-&gt;defineFeature( "docfeat");
        }
        <a href="#Query">$query</a>-&gt;pushExpression( "within", count($terms), 100000);
        <a href="#Query">$query</a>-&gt;defineFeature( "selfeat");
}
<a href="#Query">$query</a>-&gt;setMaxNofRanks( $maxNofRanks);
<a href="#Query">$query</a>-&gt;setMinRank( $minRank);
$result = return <a href="#Query">$query</a>-&gt;evaluate();
		</pre>
</div></div>
</body></html>
